# Building application forms using strategy pattern

Earlier this year we had a client that used to have a rather cumbersome old system for submitting applications. When they came to us, what they initially **desired** was a way to build their own forms. However, through agile process we determined that what they **needed** was actually just better application forms. While the content and rest of the folks focused on what the form should look like and what it should contain, I spent time deciding on the architecture and structure. 


Now, there were really two main ways of doing it, one perhaps more obvious than the other. At a glance, it sounds like "figure out the form sections, create viewmodels and views for each section and question, build a mapping engine for saving to and loading from database"-job. Okay, fair enough, lets build one form like that. Oh what's this, you need ten more forms? More viewmodels. More views! Wait, do my viewmodels really know every single one of my questions and fields and my entities are really just value objects storing data? What just happened to my domain concerns? Let's rewind back for a minute and do it the right way without turning our program into a maintenance nightmare.

To do software development right, there needs to be sufficient foresight. Domain-Driven Design allows us to acquire that foresight, provided we apply said design knowledgefully. Approaching the problem from top down as described above quickly leads one down the rabbit hole, because your domain knowledge isn't stored in one place but spread all over. Instead, we need to start thinking about the form in terms of the models they represent.

To break down the domain concerns, we need to start with the long term goal - "To enable {users} to {create} best possible {application} online". The important keywords are marked in squiggly brackets - "users create application". Therefore we can tell from this simple sentence that we have two important entities in the system - `Applications`, and `Users` that can Create said Applications.

Since we're not bothered by the users part because that's rather standard, and out of the scope of this post, we'll discuss Applications. So what is an `Application` really? The simplest way we can describe it, is: `Fields` that contain `Entries`. Now our solution also requires `Steps` and `Sections`, but from a domain standpoint, an `Application` has a `Form`, which has `Steps` and `Sections`, which have `Questions`, which in turn have `Fields`. In a visual model this would look something like this:
